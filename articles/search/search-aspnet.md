<properties
	pageTitle="Connect Azure Search with ASP.NET Web Apps | Microsoft Azure"
	description="Hook up an ASP.NET Web app with Azure Search. Learn how to connect, query, and render results using the .Net library or REST API."
	services="search"
	documentationCenter=""
	authors="HeidiSteen"
	manager="mblythe"
	editor="v-lincan"/>

<tags
	ms.service="search"
	ms.devlang="na"
	ms.workload="search"
	ms.topic="hero-article"
	ms.tgt_pltfrm="na"
	ms.date="08/26/2015"
	ms.author="heidist"/>

#How to integrate Azure Search with ASP.NET Web Apps

ASP.NET is the predominant web application framework in custom solutions that integrate with Azure Search. In this article, you’ll learn how to connect your ASP.NET web app to Azure Search, ramp up on design patterns for common operations, and review a few coding practices that could help your development experience go more smoothly. 

##Organize your code

Splitting your workloads up into standalone projects within the same Visual Studio solution gives you more flexibility in how you design, maintain, and run each program. We recommend three:

- Index creation code
- Data ingestion code
- User interaction code

In Azure Search, indexing operations and document operations – such as adding or updating documents, or executing queries – are fully independent of each other. This means you can decouple index management from your ASP.NET user interaction code that formulates search requests and renders the results.

In most of our code samples, the index is both created and loaded in one project (referred to as DataIndexer, CatalogIndexer, or DataCatalog in various samples), while the code that handles search requests and responses is placed in an ASP.NET MVC application project. In code samples, its practical to bundle index creation and document upload in one project, but production code would probably isolate these operations. Once an index is created, it’s rarely changed (and if it does change, it needs to be rebuilt), whereas documents are likely to be refreshed on a recurring basis.

Separating the workloads provides other advantages in the form of different levels of permissions for Azure Search (full admin rights versus query-only rights), use of different programming languages, more specific dependencies per program, plus the ability to revise programs independently or create multiple front-end applications that all operate on the index built and maintained by a central indexing application.

##Samples and demos using ASP.NET and Azure Search

Several code samples already exist that show how Search integrates with ASP.NET. You can go straight to code or a demo app by visiting any of these links:

- [New York City (NYC) jobs demo site](http://aka.ms/azjobsdemo)
- [Try App Service + Azure Search](search-tryappservice.md)
- [Complete list of videos, tutorials, demos, and code samples](earch-video-demo-tutorial-list.md)

##Connect to the service

To establish a connection to the service and issue requests, your Web application only needs three things: 

- A URL to the Azure Search service you’ve provisioned, formatted as https://<service-name>.search.windows.net
- An API key (GUID) that authenticates the connection to Azure Search
- An HTTPClient or SearchServiceClient to formulate the connection request

####URLs and API Keys

You can find the URL and API key in the [portal](search-create-service-portal.md) or retrieve them programmatically using the [Management REST API](https://msdn.microsoft.com/library/dn832684.aspx). 

Typically, both URL and key are placed in the web.config file of your user interaction program:

      <appSettings>
    	<add key="SearchServiceName" value="[SEARCH SERVICE NAME]" />
    	<add key="SearchServiceApiKey" value="[API KEY]" />
    	. . .
      </appSettings>

The Search service name can be the short name you specified during provisioning as long as you append the domain (search.windows.net) on the connection, or you could specify the fully qualified name (<service-name>.search.windows.net) in web.config, without the HTTPS prefix.

The API key is an authentication token generated during service provisioning (admin keys only) or generated by hand if you are creating query keys in the portal. The type of key determines which search operations are available to your application:

- admin keys (read-write permissions, 2 per service)
- query keys (read-only, up to 50 per service)

All API keys are GUIDs. Visually, there is no distinction between admin and query keys. You would need to check the portal or use the Management REST API to determine the type of key.

> [AZURE.TIP] A query key delivers a read-only experience to the client. See the [TryAppService + Azure Search](search-tryappservice.md) to test-drive the Azure Search operations that are available in a read-only service. Note that in TryAppService, the Web app code is fully modifiable – you can change any of the C# code in the ASP.NET project to modify web page layout, search query construction, or search results—it’s just the Azure Search service index and document load operations that are read-only, per the inclusion of a query api-key on the service connection.

####Client Connection

The next two code snippets set up a connection to the Search service using the URL and API key. Recall that the service name and API keys are specified in web.config file. For REST calls, admin keys must be passed in the request header, while query keys could be passed in the header or directly in the URL.

**[HttpClient](https://msdn.microsoft.com/library/system.net.http.httpclient.aspx) with REST API calls**

    public class CatalogSearch
    {
        private static readonly Uri _serviceUri;
        private static HttpClient _httpClient;
        public static string errorMessage;

        static CatalogSearch()
        {
            try
            {
                _serviceUri = new Uri("https://" + ConfigurationManager.AppSettings["SearchServiceName"] + ".search.windows.net");
                _httpClient = new HttpClient();
                _httpClient.DefaultRequestHeaders.Add("api-key", ConfigurationManager.AppSettings["SearchServiceApiKey"]);
            }
            catch (Exception e)
            {
                errorMessage = e.Message.ToString();
            }
        }

**[SearchServiceClient](https://msdn.microsoft.com/library/azure/microsoft.azure.search.searchserviceclient.aspx) with .NET**

        static UsgsSearch()
        {
            try
            {
                string searchServiceName = ConfigurationManager.AppSettings["SearchServiceName"];
                string apiKey = ConfigurationManager.AppSettings["SearchServiceApiKey"];

                // Create an HTTP reference to the catalog index. Alternatively, include the index name in the query
                _searchClient = new SearchServiceClient(searchServiceName, new SearchCredentials(apiKey));
            }
            catch (Exception e)
            {
                errorMessage = e.Message.ToString();
            }
        }

##Design patterns

A Web app that integrates with Azure Search will need to formulate queries and render the results. This section provides guidance on how to structure code for tasks executed in a program that contains user interaction code. Schema definition, index generation, and data ingestion are purposely excluded. For guidance on how to code those operations, see the walkthroughs and samples listed in [Videos, samples, and tutorials in Azure Search](search-video-demo-tutorial-list.md). 

###Query formulation

A full-text search over your index is executed on fields marked as **isSearchable** in the schema that defines the index. Given a search term input (represented below by string "q"), the search engine looks for a match inside all searchable fields, and returns results from fields marked as **isRetrievable**. 

> [AZURE.NOTE] While most fields are likely to be searchable, an index could contain fields used only in filter expressions, in which case you would mark them as non-searchable to exclude them from full-text search and non-retrievable to exclude them from the search results. 

A search query wraps the input term provided by the user into a Search request that specifies the target index, plus parameters used to filter or refine the request. Operators embedded within the search string, such as +, - or |, are handled automatically, which means there are no coding requirements for parsing a search term. Any parsing is done by the search engine, as an internal operation. You can assume that the string you pass in will be parsed and analyzed by the engine.

A search query comes in two flavors: **Search** or **Suggestions**. You would define separate methods for each type of query. **Search** is full-text search over fields in your index. **Suggestions** is the type-ahead or auto-complete query feature in Azure Search that builds a list of potential search terms based on the first three characters of user input. In most cases, you would constrain **Suggestions** to just those fields that contain relatively unique or distinctive values (like a product or publication name), as opposed to a fields that contain undifferentiated data.

The following code snippet captures a search term input in a program that uses the REST API. The input term is represented by string q, and the remaining parameters are used to pass in filter values from a faceted navigation structure on the same search page. Both the input term and filter parameters are used in the Search method.

        public ActionResult Search(string q = "", string color = null, string category = null, double? priceFrom = null, double? priceTo = null, string sort = null)
        {
            dynamic result = null;

            // If blank search, assume they want to search everything
            if (string.IsNullOrWhiteSpace(q))
                q = "*";

            result = _catalogSearch.Search(q, sort, color, category, priceFrom, priceTo);
            ViewBag.searchString = q;
            ViewBag.color = color;
            ViewBag.category = category;
            ViewBag.priceFrom = priceFrom;
            ViewBag.priceTo = priceTo;
            ViewBag.sort = sort;

            return View("Index", result);
        }
The **Search** method that accepts this query is defined as follows. Notice that it defines the parameters on the query string, plus the faceted navigation structure (supported through filters that do the heavy lifting on narrowing search results), and sort order.

        public dynamic Search(string searchText, string sort, string color, string category, double? priceFrom, double? priceTo)
        {
            string search = "&search=" + Uri.EscapeDataString(searchText);
            string facets = "&facet=color&facet=categoryName&facet=listPrice,values:10|25|100|500|1000|2500";
            string paging = "&$top=10";
            string filter = BuildFilter(color, category, priceFrom, priceTo);
            string orderby = BuildSort(sort);

            Uri uri = new Uri(_serviceUri, "/indexes/catalog/docs?$count=true" + search + facets + paging + filter + orderby);
            HttpResponseMessage response = AzureSearchHelper.SendSearchRequest(_httpClient, HttpMethod.Get, uri);
            AzureSearchHelper.EnsureSuccessfulSearchResponse(response);

            return AzureSearchHelper.DeserializeJson<dynamic>(response.Content.ReadAsStringAsync().Result);
        }

A .NET method that constructs a search string could be placed in an MVC view or in a controller. This function passes the string to the Home controller. It also defines a data structure for the results. 

    function Search() {

        var q = $("#q").val();
        
        $.post('/home/search',
        {
            q: q
        },
        function (data) {
            var searchResultsHTML = "<tr><td>FEATURE NAME</td><td>FEATURE CLASS</td>";
            searchResultsHTML += "<td>STATE ALPHA</td><td>COUNTY_NAME</td>";
            searchResultsHTML += "<td>Elevation (m)</td><td>Elevation (ft)</td><td>MAP NAME</td>";
            searchResultsHTML += "<td>DESCRIPTION</td><td>HISTORY</td><td>DATE CREATED</td>";
            searchResultsHTML += "<td>DATE EDITED</td></tr>";
            for (var i = 0; i < data.length; i++) {
                searchResultsHTML += "<td>" + data[i].Document.FEATURE_NAME + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.FEATURE_CLASS + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.STATE_ALPHA + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.COUNTY_NAME + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.ELEV_IN_M + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.ELEV_IN_FT + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.MAP_NAME + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.DESCRIPTION + "</td>";
                searchResultsHTML += "<td>" + data[i].Document.HISTORY + "</td>";
                searchResultsHTML += "<td>" + parseJsonDate(data[i].Document.DATE_CREATED) + "</td>";
                searchResultsHTML += "<td>" + parseJsonDate(data[i].Document.DATE_EDITED) + "</td></tr>";
            }

            $("#searchResults").html(searchResultsHTML);

        });

A .NET method for invoking **Search** might look like this, contained in the main C# program that provides the connection and search operation:

        public DocumentSearchResponse Search(string searchText)
        {
            // Execute search based on query string
            try
            {
                SearchParameters sp = new SearchParameters() { SearchMode = SearchMode.All };
                return _indexClient.Documents.Search(searchText, sp);
            }
            catch (Exception e)
            {
                errorMessage = e.Message.ToString();
            }
            return null;
        }


###Handling search results

Search results are returned as a rowset composed of fields that are marked in the index schema as isRetrievable. One of the simpler ways to render a result set is by using the ViewBag system object in MVC. The following code snippet is from Index.cshtml in the [AdventureWorksDemo project on CodePlex](https://azuresearchadventureworksdemo.codeplex.com/).

	@model dynamic
	
	@{
	    ViewBag.Title = "Search";
	}
	
	<h2>Product search</h2>
	
	@if (@ViewBag.errorMessage != null) {
	    @ViewBag.errorMessage
	} else {
	    <div class="container">
	        <form action="/Home/Search" method="get">
	            <input type="search" name="q" id="q" value="@ViewBag.searchString" autocomplete="off" size="100" /> <button type="submit">Search</button>
	            <input type="hidden" name="color" id="color" value="@ViewBag.color" />
	            <input type="hidden" name="category" id="category" value="@ViewBag.category" />
	            <input type="hidden" name="priceFrom" id="priceFrom" value="@ViewBag.priceFrom" />
	            <input type="hidden" name="priceTo" id="priceTo" value="@ViewBag.priceTo" />
	            <input type="hidden" name="sort" id="sort" value="@ViewBag.sort" />
	        </form>
	    </div>

###Faceted navigation

In the same Index.cshmtl file, you can find the HTML used to build a faceted navigation structure that provides classifications for self-directed filtering, progressively narrowing search results by color, price or category. 

	    if (@Model != null)
	    {
	        <div class="container">
	            <div class="row">
	                <div class="col-md-4">
	                    Colors:
	                    <ul>
	                        @foreach (var colorFacet in Model["@search.facets"].color)
	                        {
	                            <li><a href="#" onclick="document.getElementById('color').value='@colorFacet.value'; 
	document.forms[0].submit(); 
	return false;">@colorFacet.value</a> (@colorFacet.count)</li>
	                        }
	                    </ul>
	                    Categories:
	                    <ul>
	                        @foreach (var categoryFacet in Model["@search.facets"].categoryName)
	                        {
	                            <li><a href="#" onclick="document.getElementById('category').value='@categoryFacet.value'; document.forms[0].submit(); return false;">@categoryFacet.value</a> (@categoryFacet.count)</li>
	                        }
	                    </ul>
	                    Prices:
	                    <ul>
	                        @foreach (var priceFacet in Model["@search.facets"].listPrice)
	                        {
	                            if (priceFacet.count > 0)
	                            {
	                       <li><a href="#" onclick="document.getElementById('priceFrom').value=@(priceFacet.from ?? 0); document.getElementById('priceTo').value=@(priceFacet.to ?? 0); 
	document.forms[0].submit(); return false;
	">@(priceFacet.from ?? 0) - @(priceFacet.to ?? "more")</a> (@priceFacet.count)</li>
	                            }
	                        }
	                    </ul>
	                </div>
	                <div class="col-md-8">
	                    <p>
	                        Sort -
	                        <a href="#" onclick="document.getElementById('sort').value=null; document.forms[0].submit(); return false;">by relevance</a>
	                        <a href="#" onclick="document.getElementById('sort').value='listPrice'; document.forms[0].submit(); return false;">by list price</a>
	                        <a href="#" onclick="document.getElementById('sort').value='color'; document.forms[0].submit(); return false;">by color</a>
	                    </p>
	                    <p>Found @Model["@odata.count"] products in the catalog</p>
	
	                    <ul>
	                        @foreach (var product in Model.value)
	                        {
	                            <li>
	                                <h3><b>@product.name</b></h3>
	                                price: @product.listPrice, color: @product.color, weight: @product.weight, size: @product.size
	                            </li>
	                        }
	                    </ul>
	                </div>
	            </div>
	        </div>
	    }
	}


###Hit highlighting

Applying a style to the instance of the search term in a search result is called hit highlighting. In Azure Search, hit highlights are specified in the query, via the highlight search parameter, to which you give a comma-delimited list of fields to scan for matching terms. The actual style you apply is up to you. The following three code snippets are from the [TryAppService + Azure Search tutorial](search-tryappservice.md).

First, specify hit highlights as a search parameter and list the fields to check for matching terms. Specify the HTML style to use on hit highlight.

	// Set the Search parameters used when executing the search request
	     var sp = new SearchParameters
	{
	// Include a count of results in the query result
	     IncludeTotalResultCount = true,
	// Limit the results to 20 documents
	     Top = 20,
	// Enable hit-highlighting
	     HighlightFields = new[] { "FEATURE_NAME", "DESCRIPTION", "FEATURE_CLASS", "COUNTY_NAME", "STATE_ALPHA" },
	     HighlightPreTag = "<b>",
	     HighlightPostTag = "</b>",
	};

Next, iterate through the search results to find the string that needs to be highlighted.
private HtmlString RenderHitHighlightedString(SearchResult item, string fieldName)

	  {
	     if (item.Highlights != null && item.Highlights.ContainsKey(fieldName))
	      {
	      string highlightedResult = string.Join("...", item.Highlights[fieldName]);
	      return new HtmlString(highlightedResult);
	      }
	      return new HtmlString(item.Document[fieldName].ToString());
	   }

Last, provide the layout of the search results, specifying the result set that was evaluated in the previous snippet.

	<div class="col-xs-12 col-sm-6 col-md-10">
	  <p style="padding-top:20px">1 - @response.Results.Count of @response.Count results for "@searchText"</p>
	
	  <ul class="list-unstyled">
	    <!-- Cycle through the search results -->
	   @foreach (var item in response.Results)
	    {
	     <li>
	       <h3>@RenderHitHighlightedString(item, "FEATURE_NAME")</h3>
	       <p>@RenderHitHighlightedString(item, "DESCRIPTION")</p>
	       <p>@RenderHitHighlightedString(item, "FEATURE_CLASS"), elevation: @item.Document["ELEV_IN_M"] meters</p>
	       <p>@RenderHitHighlightedString(item, "COUNTY_NAME") County, @RenderHitHighlightedString(item, "STATE_ALPHA")</p>
	       <br />
	     </li>
	    }
	  </ul>
	</div>


##Common coding practices

New to MVC, .NET programming, or REST APIs?  These sections offer a few coding practices to help you get up to speed.

###MVC template

The following table summarizes how MVC template components are used in applications that include Azure Search. If you’re using MVC 4 or MVC 5, code that integrates Azure Search will generally be added to these modules

File|Description
----|-----------
Web.config|Provide the service URL and api-key. Add a reference to System.Configuration in your main program module to read the values.
Program.cs|In the main program, set up an HttpClient or SearchServiceClient to establish a connection to the service. Add the Search method to this program.
DataModel|Not used. Assuming that index creation and data load operations are in different programs, no data model is required for Azure Search in your web application.
Views|A view contains the HTML for the application web page, from search box input to dynamic HTML for handling search results.
Controllers|Query construction and error handling is typically found in the HomeContoller.cs. At a minimum, the controller should include a search method that retrieves results from Azure Search and forwards the result set to the view. 

Optionally, if you are using suggestions for auto-complete queries, you would include a method that returns suggested queries, depending on whether your index contains a matching value to the search term input provided by the user.

###When to use the .NET client library vs. REST API

For ASP.NET applications, the .NET client library is considered a better choice because it sets up the HTTP connection and handles JSON serialization and deserialization for you, which simplifies your code.

In some cases, your choice of API might be dictated by feature parity between the two approaches. Generally, the [.NET client library](https://msdn.microsoft.com/library/azure/dn951165.aspx) and [Service REST API](https://msdn.microsoft.com/library/azure/dn798935.aspx) are interchangeable so long as the operations you require are implemented in both. However, sometimes new features show up first in the REST API as part of a preview release, and only added to the .NET library months later. For example, indexers, which are used to automate data load operations from specific data source types, appeared in preview REST API first before showing up in the client library a few months later. Any restrictions on feature implementation are noted in feature documentation.

###Include AzureSearchHelper.cs for JSON serialization and deserialization in REST API

Unlike the .NET library which does this step for you, the Service REST APIs must serialize and deserialize the JSON documents in the request-response exchange with the service. JSON is the payload format for data transmission when loading or refreshing documents in the index. 

Code for JSON serialization can be found in several of samples, in a file named **AzureSearchHelper.cs**:

	using System;
	using System.Net.Http;
	using System.Text;
	using Newtonsoft.Json;
	using Newtonsoft.Json.Converters;
	using Newtonsoft.Json.Serialization;
	
	namespace CatalogCommon
	{
	    public class AzureSearchHelper
	    {
	        public const string ApiVersionString = "api-version=2014-07-31-Preview";
	
	        private static readonly JsonSerializerSettings _jsonSettings;
	
	        static AzureSearchHelper()
	        {
	            _jsonSettings = new JsonSerializerSettings
	            {
	                Formatting = Formatting.Indented, // for readability, change to None for compactness
	                ContractResolver = new CamelCasePropertyNamesContractResolver(),
	                DateTimeZoneHandling = DateTimeZoneHandling.Utc
	            };
	
	            _jsonSettings.Converters.Add(new StringEnumConverter());
	        }
	
	        public static string SerializeJson(object value)
	        {
	            return JsonConvert.SerializeObject(value, _jsonSettings);
	        }
	
	        public static T DeserializeJson<T>(string json)
	        {
	            return JsonConvert.DeserializeObject<T>(json, _jsonSettings);
	        }
	
	        public static HttpResponseMessage SendSearchRequest(HttpClient client, HttpMethod method, Uri uri, string json = null)
	        {
	            UriBuilder builder = new UriBuilder(uri);
	            string separator = string.IsNullOrWhiteSpace(builder.Query) ? string.Empty : "&";
	            builder.Query = builder.Query.TrimStart('?') + separator + ApiVersionString;
	
	            var request = new HttpRequestMessage(method, builder.Uri);
	
	            if (json != null)
	            {
	                request.Content = new StringContent(json, Encoding.UTF8, "application/json");
	            }
	
	            return client.SendAsync(request).Result;
	        }
	
	        public static void EnsureSuccessfulSearchResponse(HttpResponseMessage response)
	        {
	            if (!response.IsSuccessStatusCode)
	            {
	                string error = response.Content == null ? null : response.Content.ReadAsStringAsync().Result;
	                throw new Exception("Search request failed: " + error);
	            }
	        }
	    }
	}


##Next steps

To further your understanding of Azure Search and ASP.NET integration, visit the following links:

- [How to use Azure Search from a .NET Application](search-howto-dotnet-sdk.md) 
- [Azure Search Developer Case Study](search-dev-case-study-whattopedia.md)
- [Typical workflow for Azure Search development](search-workflow.md) 

